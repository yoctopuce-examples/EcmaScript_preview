<HTML>
<HEAD>
<title>EcmaScript API</title>
<link rel="apple-touch-icon-precomposed" href="data:image/png;base64,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"/>
<meta name="apple-mobile-web-app-capable" content="yes" />
<style type="text/css">
/*********************************************************************
 *
 * $Id: yoctolib-cpp-FR.html 22323 2015-12-11 09:48:39Z seb $
 *
 * Searchable documentation browser for Yoctopuce Library
 *
 * (note: the reference file to edit is yoctolib-cpp-FR.html)
 *
 * - - - - - - - - - License information: - - - - - - - - -
 *
 * Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 * 1) If you have obtained this file from www.yoctopuce.com,
 *    Yoctopuce Sarl licenses to you (hereafter Licensee) the
 *    right to use, modify, copy, and integrate this source file
 *    into your own solution for the sole purpose of interfacing
 *    a Yoctopuce product with Licensee's solution.
 *
 *    The use of this file and all relationship between Yoctopuce
 *    and Licensee are governed by Yoctopuce General Terms and
 *    Conditions.
 *
 *    THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 *    WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
 *    WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *    FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *    EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *    INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *    COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
 *    SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
 *    LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *    CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *    BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *    WARRANTY, OR OTHERWISE.
 *
 * 2) If your intent is not to interface with Yoctopuce products,
 *    you are not entitled to use, read or create any derived
 *    material from this file.
 *
 *********************************************************************/
BODY
{ font-family: Arial, sans-serif;
  font-size: 14px;
  text-align : justify;
}

div#BannerLayer
{ position:absolute;
  left:0px;
  top:0px;
  width:800px;
  height:80px;
  overflow:hidden;
  Font-size:64px;
  font-weight:bold;
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAIAAADITs03AAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzoyNjozNCArMDEwMCBiImgAAAAHdElNRQfbDA0GIhbUXPxTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAAB9JREFUeNpjeP78ORMDAwPT////wTQ+NrHqRvWTrR8AfCxgH0BR2OYAAAAASUVORK5CYII=);
  }
div#MarginLayer
{ position:absolute;
  left:0px;
  top:80px;
  width:250px;
  height:490px;
  background-color:#f8f8f8;
  overflow:auto;

}

div#FunctionsLayer
{ position:absolute;
  left:250px;
  top:80px;
  width:600px;
  height:490px;
  overflow:auto;
}

div#FooterLayer
{ position:absolute;
  left:0px;
  top:570px;
  width: 800px;
  height:30px;
  background-color: #E0E0E0 ;
  overflow:hidden;
}

div#separatorLayer
{ position:absolute;
  width:10px;
  height:470px;
  border-left:2px solid #b0b0b0 ;
  overflow:hidden;
  cursor :col-resize;
}

div.container
{ width:100%;
  height:100%;
}

span.classheader
{ display:inline-block;
  width:100%;
  background-color:#f0f0f0;
  padding-top:3px;
  padding-bottom:3px;
  margin-bottom:3px;
  margin-top:px;
}

A.extLink
 { color : grey;
   text-decoration:none;
   font-size:10px;
 }

span.classheader A
 { color: navy;
   text-decoration:none;
   font-weight:bold;
 }

img.expandColapse
 { vertical-align: middle;
 }

div.methodsList
 { margin-top:0px;
   padding-top:0px;
   padding-left:10px;
   margin-bottom:10px;
 }

div.methodsList A
 { color: navy;
   text-decoration:none;
 }

div#FunctionsLayerInner
 { margin-left:10px;
   margin-top:10px;
   margin-right:20px;
 }

span.funcHeader
 { color: navy;
   text-decoration:none;
   font-size:25px;
   margin-botton:20px;
   font-weight:bold;
 }

span#pn , td.pn
 { font-weight:bold;
   color:#004000;

 }

td.pn
 {vertical-align:top}

span.paramAndRet
 {font-weight:bold;

 }

table
 {font-size:14px;}

span.prototype
 { margin-left:10px;
   margin-right:10px;
   padding-top:5px;
   padding-bottom:5px;
   padding-left:5px;
   padding-right:5px;
   font-weight:bold;
   background-color: #f8f8f8;
   -moz-border-radius: 5px;
   -webkit-border-top-left-radius:  5px;
   -webkit-border-top-right-radius: 5px;
   -webkit-border-bottom-right-radius:  5px;
   -webkit-border-bottom-left-radius:  5px;
    color:navy;
 }

p.protolabel
 { border-top:1px  solid #f0f0f0;
 }

P.protoretval
 { margin-left:20px;}

.paramtable
 { margin-left:20px; margin-top:0px;}

P.protoretval
 { margin-left:20px;}

input
 { border :  1px solid gray;
   border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-border-top-left-radius:  2px;
  -webkit-border-top-right-radius: 2px;
  -webkit-border-bottom-right-radius:  2px;
  -webkit-border-bottom-left-radius:  2px;
 }

td#langdt
 { vertical-align:bottom;
   text-align:right;
   color:#404040;
 }

td#version
 { text-align:right;
   font-size:12px;
   color:grey;
 }

p.methodlist
 { border-top:1px solid #e0e0e0;
 }

a.protoindex
 { text-decoration:none;
   font-weight:bold;
   color:navy;
 }

span.synlist
 { margin-left:10px;
 }

p.include
 { font-weight:bold;
   color:navy;
   margin-left:20px;
 }
</style>

<SCRIPT type="text/JavaScript">
<!--
var WinW;
var WinH;

var plusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIlhI9pwe2+nmQRAllbpvft8IWdgnAcOXYWpmqt6b2gLE7TZ6N6AQA7";
var minusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIihI9pwe2+nmRxvmobzmHnqCAUMIZkd3KjqqWqZ8GTLJl2AQA7";

var marginSize=250;
var resizeCallBacks= new Array();
var SVN_Id = '$Id: yoctolib-cpp-FR.html 22323 2015-12-11 09:48:39Z seb $';
var Version = (SVN_Id.split(' '))[3];
var doc = new Array();

//--- (generated code: YAPI)
doc['YAPI']={'':{syn:'General functions',inc:'import { YAPI, YModule } from &#039;lib/yocto_api&#039;',cmt:'<p>These general functions should be used to initialize and configure the Yoctopuce library. In most cases, a simple call to function <tt>yRegisterHub()</tt> should be enough. The module-specific functions <tt>yFind...()</tt> or <tt>yFirst...()</tt> should then be used to retrieve an object that provides interaction with the module.</p>'}};
doc['YAPI']['CheckLogicalName']={syn:'Checks if a given string is valid as logical name for a module or a function.',lib:'YAPI.CheckLogicalName()',pro:'function CheckLogicalName(<span id=pn>name</span>)',cmt:'<p>Checks if a given string is valid as logical name for a module or a function. A valid logical name has a maximum of 19 characters, all among <tt>A..Z</tt>, <tt>a..z</tt>, <tt>0..9</tt>, <tt>_</tt>, and <tt>-</tt>. If you try to configure a logical name with an incorrect string, the invalid characters are ignored.</p>',par:{name:'a string containing the name to check.'},ret:'<tt>true</tt> if the name is valid, <tt>false</tt> otherwise.'};
doc['YAPI']['DisableExceptions']={syn:'Disables the use of exceptions to report runtime errors.',lib:'YAPI.DisableExceptions()',pro:'function DisableExceptions()',cmt:'<p>Disables the use of exceptions to report runtime errors. When exceptions are disabled, every function returns a specific error value which depends on its type and which is documented in this reference manual.</p>'};
doc['YAPI']['EnableExceptions']={syn:'Re-enables the use of exceptions for runtime error handling.',lib:'YAPI.EnableExceptions()',pro:'function EnableExceptions()',cmt:'<p>Re-enables the use of exceptions for runtime error handling. Be aware than when exceptions are enabled, every function that fails triggers an exception. If the exception is not caught by the user code, it either fires the debugger or aborts (i.e. crash) the program. On failure, throws an exception or returns a negative error code.</p>'};
doc['YAPI']['FreeAPI']={syn:'Frees dynamically allocated memory blocks used by the Yoctopuce library.',lib:'YAPI.FreeAPI()',pro:'function FreeAPI()',cmt:'<p>Frees dynamically allocated memory blocks used by the Yoctopuce library. It is generally not required to call this function, unless you want to free all dynamically allocated memory blocks in order to track a memory leak for instance. You should not call any other library function after calling <tt>yFreeAPI()</tt>, or your program will crash.</p>'};
doc['YAPI']['GetAPIVersion']={syn:'Returns the version identifier for the Yoctopuce library in use.',lib:'YAPI.GetAPIVersion()',pro:'function GetAPIVersion()',cmt:'<p>Returns the version identifier for the Yoctopuce library in use. The version is a string in the form <tt>\x22Major.Minor.Build\x22</tt>, for instance <tt>\x221.01.5535\x22</tt>. For languages using an external DLL (for instance C#, VisualBasic or Delphi), the character string includes as well the DLL version, for instance <tt>\x221.01.5535 (1.01.5439)\x22</tt>.</p><p> If you want to verify in your code that the library version is compatible with the version that you have used during development, verify that the major number is strictly equal and that the minor number is greater or equal. The build number is not relevant with respect to the library compatibility.</p>',ret:'a character string describing the library version.'};
doc['YAPI']['GetTickCount']={syn:'Returns the current value of a monotone millisecond-based time counter.',lib:'YAPI.GetTickCount()',pro:'function GetTickCount()',cmt:'<p>Returns the current value of a monotone millisecond-based time counter. This counter can be used to compute delays in relation with Yoctopuce devices, which also uses the millisecond as timebase.</p>',ret:'a long integer corresponding to the millisecond counter.'};
doc['YAPI']['HandleEvents']={syn:'Maintains the device-to-library communication channel.',lib:'YAPI.HandleEvents()',pro:'function HandleEvents(<span id=pn>errmsg</span>)',cmt:'<p>Maintains the device-to-library communication channel. If your program includes significant loops, you may want to include a call to this function to make sure that the library takes care of the information pushed by the modules on the communication channels. This is not strictly necessary, but it may improve the reactivity of the library for the following commands.</p><p> This function may signal an error in case there is a communication problem while contacting a module.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['InitAPI']={syn:'Initializes the Yoctopuce programming library explicitly.',lib:'YAPI.InitAPI()',pro:'function InitAPI(<span id=pn>mode</span>, <span id=pn>errmsg</span>)',cmt:'<p>Initializes the Yoctopuce programming library explicitly. It is not strictly needed to call <tt>yInitAPI()</tt>, as the library is automatically initialized when calling <tt>yRegisterHub()</tt> for the first time.</p><p> When <tt>Y_DETECT_NONE</tt> is used as detection <tt>mode</tt>, you must explicitly use <tt>yRegisterHub()</tt> to point the API to the VirtualHub on which your devices are connected before trying to access them.</p>',par:{mode:'an integer corresponding to the type of automatic device detection to use. Possible values are <tt>Y_DETECT_NONE</tt>, <tt>Y_DETECT_USB</tt>, <tt>Y_DETECT_NET</tt>, and <tt>Y_DETECT_ALL</tt>.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['PreregisterHub']={syn:'Fault-tolerant alternative to RegisterHub().',lib:'YAPI.PreregisterHub()',pro:'function PreregisterHub(<span id=pn>url</span>, <span id=pn>errmsg</span>)',cmt:'<p>Fault-tolerant alternative to RegisterHub(). This function has the same purpose and same arguments as <tt>RegisterHub()</tt>, but does not trigger an error when the selected hub is not available at the time of the function call. This makes it possible to register a network hub independently of the current connectivity, and to try to contact it only when a device is actively needed.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui>,<ui>\x22callback\x22</ui> or the root URL of the hub to monitor',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['RegisterDeviceArrivalCallback']={syn:'Register a callback function, to be called each time a device is plugged.',lib:'YAPI.RegisterDeviceArrivalCallback()',pro:'function RegisterDeviceArrivalCallback(<span id=pn>arrivalCallback</span>)',cmt:'<p>Register a callback function, to be called each time a device is plugged. This callback will be invoked while <tt>yUpdateDeviceList</tt> is running. You will have to call this function on a regular basis.</p>',par:{arrivalCallback:'a procedure taking a <tt>YModule</tt> parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['RegisterDeviceRemovalCallback']={syn:'Register a callback function, to be called each time a device is unplugged.',lib:'YAPI.RegisterDeviceRemovalCallback()',pro:'function RegisterDeviceRemovalCallback(<span id=pn>removalCallback</span>)',cmt:'<p>Register a callback function, to be called each time a device is unplugged. This callback will be invoked while <tt>yUpdateDeviceList</tt> is running. You will have to call this function on a regular basis.</p>',par:{removalCallback:'a procedure taking a <tt>YModule</tt> parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['RegisterHub']={syn:'Setup the Yoctopuce library to use modules connected on a given machine.',lib:'YAPI.RegisterHub()',pro:'function RegisterHub(<span id=pn>url</span>, <span id=pn>errmsg</span>)',cmt:'<p>Setup the Yoctopuce library to use modules connected on a given machine. The parameter will determine how the API will work. Use the following values:</p><p> <b>usb</b>: When the <ui>usb</ui> keyword is used, the API will work with devices connected directly to the USB bus. Some programming languages such a Javascript, PHP, and Java don\x27t provide direct access to USB hardware, so <ui>usb</ui> will not work with these. In this case, use a VirtualHub or a networked YoctoHub (see below).</p><p> <b><i>x.x.x.x</i></b> or <b><i>hostname</i></b>: The API will use the devices connected to the host with the given IP address or hostname. That host can be a regular computer running a VirtualHub, or a networked YoctoHub such as YoctoHub-Ethernet or YoctoHub-Wireless. If you want to use the VirtualHub running on you local computer, use the IP address 127.0.0.1.</p><p> <b>callback</b>: that keyword make the API run in \x22<i>HTTP Callback</i>\x22 mode. This a special mode allowing to take control of Yoctopuce devices through a NAT filter when using a VirtualHub or a networked YoctoHub. You only need to configure your hub to call your server script on a regular basis. This mode is currently available for PHP and Node.JS only.</p><p> Be aware that only one application can use direct USB access at a given time on a machine. Multiple access would cause conflicts while trying to access the USB modules. In particular, this means that you must stop the VirtualHub software before starting an application that uses direct USB access. The workaround for this limitation is to setup the library to use the VirtualHub rather than direct USB access.</p><p> If access control has been activated on the hub, virtual or not, you want to reach, the URL parameter should look like:</p><p> <tt>http://username:password@address:port</tt></p><p> You can call <i>RegisterHub</i> several times to connect to several machines.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui>,<ui>\x22callback\x22</ui> or the root URL of the hub to monitor',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['Sleep']={syn:'Pauses the execution flow for a specified duration.',lib:'YAPI.Sleep()',pro:'function Sleep(<span id=pn>ms_duration</span>, <span id=pn>errmsg</span>)',cmt:'<p>Pauses the execution flow for a specified duration. This function implements a passive waiting loop, meaning that it does not consume CPU cycles significantly. The processor is left available for other threads and processes. During the pause, the library nevertheless reads from time to time information from the Yoctopuce modules by calling <tt>yHandleEvents()</tt>, in order to stay up-to-date.</p><p> This function may signal an error in case there is a communication problem while contacting a module.</p>',par:{ms_duration:'an integer corresponding to the duration of the pause, in milliseconds.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['UnregisterHub']={syn:'Setup the Yoctopuce library to no more use modules connected on a previously registered machine with RegisterHub.',lib:'YAPI.UnregisterHub()',pro:'function UnregisterHub(<span id=pn>url</span>)',cmt:'<p>Setup the Yoctopuce library to no more use modules connected on a previously registered machine with RegisterHub.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui> or the root URL of the hub to monitor'}};
doc['YAPI']['UpdateDeviceList']={syn:'Triggers a (re)detection of connected Yoctopuce modules.',lib:'YAPI.UpdateDeviceList()',pro:'function UpdateDeviceList(<span id=pn>errmsg</span>)',cmt:'<p>Triggers a (re)detection of connected Yoctopuce modules. The library searches the machines or USB ports previously registered using <tt>yRegisterHub()</tt>, and invokes any user-defined callback function in case a change in the list of connected devices is detected.</p><p> This function can be called as frequently as desired to refresh the device list and to make the application aware of hot-plug events.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: YAPI)
//--- (generated code: Sensor)
doc['Sensor']={'':{syn:'Sensor function interface',inc:'import { YAPI, YModule } from &#039;lib/yocto_api&#039;',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Sensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'sensor.calibrateFromPoints()',pro:'function calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'sensor.get_recordedData()',pro:'function get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Sensor']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'sensor.isSensorReady()',pro:'function isSensorReady()',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Sensor']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'sensor.loadCalibrationPoints()',pro:'function loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'sensor.registerTimedReportCallback()',pro:'function registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Sensor']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'sensor.startDataLogger()',pro:'function startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Sensor']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'sensor.stopDataLogger()',pro:'function stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Sensor)
//--- (generated code: FirmwareUpdate)
doc['FirmwareUpdate']={'':{syn:'Control interface for the firmware update process',inc:'import { YAPI, YModule } from &#039;lib/yocto_api&#039;',cmt:'<p>The YFirmwareUpdate class let you control the firmware update of a Yoctopuce module. This class should not be instantiate directly, instead the method <tt>updateFirmware</tt> should be called to get an instance of YFirmwareUpdate.</p>'}};
doc['FirmwareUpdate']['CheckFirmware']={syn:'Test if the byn file is valid for this module.',lib:'YFirmwareUpdate.CheckFirmware()',pro:'function CheckFirmware(<span id=pn>serial</span>, <span id=pn>path</span>, <span id=pn>minrelease</span>)',cmt:'<p>Test if the byn file is valid for this module. It\x27s possible to pass an directory instead of a file. In this case this method return the path of the most recent appropriate byn file. This method will ignore firmware that are older than mintrelase.</p>',par:{serial:'the serial number of the module to update',path:'the path of a byn file or a directory that contain byn files',minrelease:'an positif integer'},ret:': the path of the byn file to use or a empty string if no byn files match the requirement',ext:'On failure, returns a string that start with \x22error:\x22.'};
doc['FirmwareUpdate']['get_progress']={syn:'Returns the progress of the firmware update, on a scale from 0 to 100.',lib:'firmwareupdate.get_progress()',pro:'function get_progress()',cmt:'<p>Returns the progress of the firmware update, on a scale from 0 to 100. When the object is instantiated, the progress is zero. The value is updated during the firmware update process until the value of 100 is reached. The 100 value means that the firmware update was completed successfully. If an error occurs during the firmware update, a negative value is returned, and the error message can be retrieved with <tt>get_progressMessage</tt>.</p>',ret:'an integer in the range 0 to 100 (percentage of completion) or a negative error code in case of failure.'};
doc['FirmwareUpdate']['get_progressMessage']={syn:'Returns the last progress message of the firmware update process.',lib:'firmwareupdate.get_progressMessage()',pro:'function get_progressMessage()',cmt:'<p>Returns the last progress message of the firmware update process. If an error occurs during the firmware update process, the error message is returned</p>',ret:'a string with the latest progress message, or the error message.'};
doc['FirmwareUpdate']['startUpdate']={syn:'Starts the firmware update process.',lib:'firmwareupdate.startUpdate()',pro:'function startUpdate()',cmt:'<p>Starts the firmware update process. This method starts the firmware update process in background. This method returns immediately. You can monitor the progress of the firmware update with the <tt>get_progress()</tt> and <tt>get_progressMessage()</tt> methods.</p>',ret:'an integer in the range 0 to 100 (percentage of completion), or a negative error code in case of failure.',ext:'On failure returns a negative error code.'};
//--- (end of generated code: FirmwareUpdate)
//--- (generated code: Module)
var Language='EcmaScript';
var IncludeLabel='In order to use the functions described here, you should include:';
var ParamLabel='Parameters :';
var ReturnLabel='Returns :';
var AbbrevHint='The API features two syntaxes : one is purely object oriented, the other is more compact.';
var NotFound='No match found';
var AbbrevLabel='Use abbreviated names';
var UseShortcuts=false;
var sub={YAPI_SUCCESS:'YAPI.SUCCESS',YAPI_NOT_INITIALIZED:'YAPI.NOT_INITIALIZED',YAPI_INVALID_ARGUMENT:'YAPI.INVALID_ARGUMENT',YAPI_NOT_SUPPORTED:'YAPI.NOT_SUPPORTED',YAPI_DEVICE_NOT_FOUND:'YAPI.DEVICE_NOT_FOUND',YAPI_VERSION_MISMATCH:'YAPI.VERSION_MISMATCH',YAPI_DEVICE_BUSY:'YAPI.DEVICE_BUSY',YAPI_TIMEOUT:'YAPI.TIMEOUT',YAPI_IO_ERROR:'YAPI.IO_ERROR',YAPI_NO_MORE_DATA:'YAPI.NO_MORE_DATA',YAPI_EXHAUSTED:'YAPI.EXHAUSTED',YAPI_DOUBLE_ACCES:'YAPI.DOUBLE_ACCES',YAPI_UNAUTHORIZED:'YAPI.UNAUTHORIZED',YAPI_RTC_NOT_READY:'YAPI.RTC_NOT_READY',YAPI_FILE_NOT_FOUND:'YAPI.FILE_NOT_FOUND',null:'null'};
doc['Module']={'':{syn:'Module control interface',inc:'import { YAPI, YModule } from &#039;lib/yocto_api&#039;',cmt:'<p>This interface is identical for all Yoctopuce USB modules. It can be used to control the module global parameters, and to enumerate the functions provided by each module.</p>'}};
doc['Module']['FindModule']={syn:'Allows you to find a module from its serial number or from its logical name.',lib:'YModule.FindModule()',pro:'function FindModule(<span id=pn>func</span>, <span id=pn>obj_yapi</span>, <span id=pn>YAPI</span>)',cmt:'<p>Allows you to find a module from its serial number or from its logical name.</p><p> This function does not require that the module is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YModule.isOnline()</tt> to test if the module is indeed online at a given time. In case of ambiguity when looking for a module by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string containing either the serial number or the logical name of the desired module'},ret:'a <tt>YModule</tt> object allowing you to drive the module or get additional information on the module.'};
doc['Module']['FirstModule']={syn:'Starts the enumeration of modules currently accessible.',lib:'YModule.FirstModule()',pro:'function FirstModule(<span id=pn>obj_yapi</span>, <span id=pn>YAPI</span>)',cmt:'<p>Starts the enumeration of modules currently accessible. Use the method <tt>YModule.nextModule()</tt> to iterate on the next modules.</p>',ret:'a pointer to a <tt>YModule</tt> object, corresponding to the first module currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Module']['checkFirmware']={syn:'Tests whether the byn file is valid for this module.',lib:'module.checkFirmware()',pro:'function checkFirmware(<span id=pn>path</span>, <span id=pn>onlynew</span>)',cmt:'<p>Tests whether the byn file is valid for this module. This method is useful to test if the module needs to be updated. It is possible to pass a directory as argument instead of a file. In this case, this method returns the path of the most recent appropriate byn file. If the parameter onlynew is true, the function discards firmware that are older or equal to the installed firmware.</p>',par:{path:'the path of a byn file or a directory that contains byn files',onlynew:'returns only files that are strictly newer'},ret:': the path of the byn file to use or a empty string if no byn files matches the requirement',ext:'On failure, throws an exception or returns a string that start with \x22error:\x22.'};
doc['Module']['clearCache']={syn:'Invalidates the cache.',lib:'module.clearCache()',pro:'function clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the module attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Module']['describe']={syn:'Returns a descriptive text that identifies the module.',lib:'module.describe()',pro:'function describe()',cmt:'<p>Returns a descriptive text that identifies the module. The text may include either the logical name or the serial number of the module.</p>',ret:'a string that describes the module'};
doc['Module']['download']={syn:'Downloads the specified built-in file and returns a binary buffer with its content.',lib:'module.download()',pro:'function download(<span id=pn>pathname</span>)',cmt:'<p>Downloads the specified built-in file and returns a binary buffer with its content.</p>',par:{pathname:'name of the new file to load'},ret:'a binary buffer with the file content',ext:'On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['functionCount']={syn:'Returns the number of functions (beside the \x22module\x22 interface) available on the module.',lib:'module.functionCount()',pro:'function functionCount()',cmt:'<p>Returns the number of functions (beside the \x22module\x22 interface) available on the module.</p>',ret:'the number of functions on the module',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['functionId']={syn:'Retrieves the hardware identifier of the <i>n</i>th function on the module.',lib:'module.functionId()',pro:'function functionId(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the hardware identifier of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the unambiguous hardware identifier of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionName']={syn:'Retrieves the logical name of the <i>n</i>th function on the module.',lib:'module.functionName()',pro:'function functionName(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the logical name of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the logical name of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionType']={syn:'Retrieves the type of the <i>n</i>th function on the module.',lib:'module.functionType()',pro:'function functionType(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the type of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a the type of the function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionValue']={syn:'Retrieves the advertised value of the <i>n</i>th function on the module.',lib:'module.functionValue()',pro:'function functionValue(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the advertised value of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a short string (up to 6 characters) corresponding to the advertised value of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['get_allSettings']={syn:'Returns all the settings and uploaded files of the module.',lib:'module.get_allSettings()',pro:'function get_allSettings()',cmt:'<p>Returns all the settings and uploaded files of the module. Useful to backup all the logical names, calibrations parameters, \x09\x09and uploaded files of a connected module.</p>',ret:'a binary buffer with all the settings.',ext:'On failure, throws an exception or returns an binary object of size 0.'};
doc['Module']['get_beacon']={syn:'Returns the state of the localization beacon.',lib:'module.get_beacon()',pro:'function get_beacon()',cmt:'<p>Returns the state of the localization beacon.</p>',ret:'either <tt>Y_BEACON_OFF</tt> or <tt>Y_BEACON_ON</tt>, according to the state of the localization beacon',ext:'On failure, throws an exception or returns <tt>Y_BEACON_INVALID</tt>.'};
doc['Module']['get_errorMessage']={syn:'Returns the error message of the latest error with this module object.',lib:'module.get_errorMessage()',pro:'function get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this module object. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this module object'};
doc['Module']['get_errorType']={syn:'Returns the numerical error code of the latest error with this module object.',lib:'module.get_errorType()',pro:'function get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this module object. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this module object'};
doc['Module']['get_firmwareRelease']={syn:'Returns the version of the firmware embedded in the module.',lib:'module.get_firmwareRelease()',pro:'function get_firmwareRelease()',cmt:'<p>Returns the version of the firmware embedded in the module.</p>',ret:'a string corresponding to the version of the firmware embedded in the module',ext:'On failure, throws an exception or returns <tt>Y_FIRMWARERELEASE_INVALID</tt>.'};
doc['Module']['get_functionIds']={syn:'Retrieve all hardware identifier that match the type passed in argument.',lib:'module.get_functionIds()',pro:'function get_functionIds(<span id=pn>funType</span>)',cmt:'<p>Retrieve all hardware identifier that match the type passed in argument.</p>',par:{funType:'The type of function (Relay, LightSensor, Voltage,...)'},ret:': A array of string.'};
doc['Module']['get_hardwareId']={syn:'Returns the unique hardware identifier of the module.',lib:'module.get_hardwareId()',pro:'function get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the module. The unique hardware identifier is made of the device serial number followed by string \x22.module\x22.</p>',ret:'a string that uniquely identifies the module'};
doc['Module']['get_icon2d']={syn:'Returns the icon of the module.',lib:'module.get_icon2d()',pro:'function get_icon2d()',cmt:'<p>Returns the icon of the module. The icon is a PNG image and does not exceeds 1536 bytes.</p>',ret:'a binary buffer with module icon, in png format. On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['get_lastLogs']={syn:'Returns a string with last logs of the module.',lib:'module.get_lastLogs()',pro:'function get_lastLogs()',cmt:'<p>Returns a string with last logs of the module. This method return only logs that are still in the module.</p>',ret:'a string with last logs of the module. On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['get_logicalName']={syn:'Returns the logical name of the module.',lib:'module.get_logicalName()',pro:'function get_logicalName()',cmt:'<p>Returns the logical name of the module.</p>',ret:'a string corresponding to the logical name of the module',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Module']['get_luminosity']={syn:'Returns the luminosity of the module informative leds (from 0 to 100).',lib:'module.get_luminosity()',pro:'function get_luminosity()',cmt:'<p>Returns the luminosity of the module informative leds (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative leds (from 0 to 100)',ext:'On failure, throws an exception or returns <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Module']['get_persistentSettings']={syn:'Returns the current state of persistent module settings.',lib:'module.get_persistentSettings()',pro:'function get_persistentSettings()',cmt:'<p>Returns the current state of persistent module settings.</p>',ret:'a value among <tt>Y_PERSISTENTSETTINGS_LOADED</tt>, <tt>Y_PERSISTENTSETTINGS_SAVED</tt> and <tt>Y_PERSISTENTSETTINGS_MODIFIED</tt> corresponding to the current state of persistent module settings',ext:'On failure, throws an exception or returns <tt>Y_PERSISTENTSETTINGS_INVALID</tt>.'};
doc['Module']['get_productId']={syn:'Returns the USB device identifier of the module.',lib:'module.get_productId()',pro:'function get_productId()',cmt:'<p>Returns the USB device identifier of the module.</p>',ret:'an integer corresponding to the USB device identifier of the module',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTID_INVALID</tt>.'};
doc['Module']['get_productName']={syn:'Returns the commercial name of the module, as set by the factory.',lib:'module.get_productName()',pro:'function get_productName()',cmt:'<p>Returns the commercial name of the module, as set by the factory.</p>',ret:'a string corresponding to the commercial name of the module, as set by the factory',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTNAME_INVALID</tt>.'};
doc['Module']['get_productRelease']={syn:'Returns the hardware release version of the module.',lib:'module.get_productRelease()',pro:'function get_productRelease()',cmt:'<p>Returns the hardware release version of the module.</p>',ret:'an integer corresponding to the hardware release version of the module',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTRELEASE_INVALID</tt>.'};
doc['Module']['get_rebootCountdown']={syn:'Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.',lib:'module.get_rebootCountdown()',pro:'function get_rebootCountdown()',cmt:'<p>Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.</p>',ret:'an integer corresponding to the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled',ext:'On failure, throws an exception or returns <tt>Y_REBOOTCOUNTDOWN_INVALID</tt>.'};
doc['Module']['get_serialNumber']={syn:'Returns the serial number of the module, as set by the factory.',lib:'module.get_serialNumber()',pro:'function get_serialNumber()',cmt:'<p>Returns the serial number of the module, as set by the factory.</p>',ret:'a string corresponding to the serial number of the module, as set by the factory',ext:'On failure, throws an exception or returns <tt>Y_SERIALNUMBER_INVALID</tt>.'};
doc['Module']['get_upTime']={syn:'Returns the number of milliseconds spent since the module was powered on.',lib:'module.get_upTime()',pro:'function get_upTime()',cmt:'<p>Returns the number of milliseconds spent since the module was powered on.</p>',ret:'an integer corresponding to the number of milliseconds spent since the module was powered on',ext:'On failure, throws an exception or returns <tt>Y_UPTIME_INVALID</tt>.'};
doc['Module']['get_usbCurrent']={syn:'Returns the current consumed by the module on the USB bus, in milli-amps.',lib:'module.get_usbCurrent()',pro:'function get_usbCurrent()',cmt:'<p>Returns the current consumed by the module on the USB bus, in milli-amps.</p>',ret:'an integer corresponding to the current consumed by the module on the USB bus, in milli-amps',ext:'On failure, throws an exception or returns <tt>Y_USBCURRENT_INVALID</tt>.'};
doc['Module']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'module.get_userData()',pro:'function get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Module']['get_userVar']={syn:'Returns the value previously stored in this attribute.',lib:'module.get_userVar()',pro:'function get_userVar()',cmt:'<p>Returns the value previously stored in this attribute. On startup and after a device reboot, the value is always reset to zero.</p>',ret:'an integer corresponding to the value previously stored in this attribute',ext:'On failure, throws an exception or returns <tt>Y_USERVAR_INVALID</tt>.'};
doc['Module']['hasFunction']={syn:'Test if the device has a specific function.',lib:'module.hasFunction()',pro:'function hasFunction(<span id=pn>funcId</span>)',cmt:'<p>Test if the device has a specific function. This method took an function identifier and return a boolean.</p>',par:{funcId:'the requested function identifier'},ret:': true if the device has the function identifier'};
doc['Module']['isOnline']={syn:'Checks if the module is currently reachable, without raising any error.',lib:'module.isOnline()',pro:'function isOnline()',cmt:'<p>Checks if the module is currently reachable, without raising any error. If there are valid cached values for the module, that have not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the requested module.</p>',ret:'<tt>true</tt> if the module can be reached, and <tt>false</tt> otherwise'};
doc['Module']['load']={syn:'Preloads the module cache with a specified validity duration.',lib:'module.load()',pro:'function load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the module cache with a specified validity duration. By default, whenever accessing a device, all module attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded module parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['nextModule']={syn:'Continues the module enumeration started using <tt>yFirstModule()</tt>.',lib:'module.nextModule()',pro:'function nextModule()',cmt:'<p>Continues the module enumeration started using <tt>yFirstModule()</tt>.</p>',ret:'a pointer to a <tt>YModule</tt> object, corresponding to the next module found, or a <tt>null</tt> pointer if there are no more modules to enumerate.'};
doc['Module']['reboot']={syn:'Schedules a simple module reboot after the given number of seconds.',lib:'module.reboot()',pro:'function reboot(<span id=pn>secBeforeReboot</span>)',cmt:'<p>Schedules a simple module reboot after the given number of seconds.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['revertFromFlash']={syn:'Reloads the settings stored in the nonvolatile memory, as when the module is powered on.',lib:'module.revertFromFlash()',pro:'function revertFromFlash()',cmt:'<p>Reloads the settings stored in the nonvolatile memory, as when the module is powered on.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['saveToFlash']={syn:'Saves current settings in the nonvolatile memory of the module.',lib:'module.saveToFlash()',pro:'function saveToFlash()',cmt:'<p>Saves current settings in the nonvolatile memory of the module. Warning: the number of allowed save operations during a module life is limited (about 100000 cycles). Do not call this function within a loop.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_allSettings']={syn:'Restores all the settings of the module.',lib:'module.set_allSettings()',pro:'function set_allSettings(<span id=pn>settings</span>)',cmt:'<p>Restores all the settings of the module. Useful to restore all the logical names and calibrations parameters of a module from a backup.Remember to call the <tt>saveToFlash()</tt> method of the module if the modifications must be kept.</p>',par:{settings:'a binary buffer with all the settings.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_allSettingsAndFiles']={syn:'Restores all the settings and uploaded files of the module.',lib:'module.set_allSettingsAndFiles()',pro:'function set_allSettingsAndFiles(<span id=pn>settings</span>)',cmt:'<p>Restores all the settings and uploaded files of the module. Useful to restore all the logical names and calibrations parameters, uploaded \x09 files etc.. of a module from a backup.Remember to call the <tt>saveToFlash()</tt> method of the module if the modifications must be kept.</p>',par:{settings:'a binary buffer with all the settings.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_beacon']={syn:'Turns on or off the module localization beacon.',lib:'module.set_beacon()',pro:'function set_beacon(<span id=pn>newval</span>)',cmt:'<p>Turns on or off the module localization beacon.</p>',par:{newval:'either <tt>Y_BEACON_OFF</tt> or <tt>Y_BEACON_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_logicalName']={syn:'Changes the logical name of the module.',lib:'module.set_logicalName()',pro:'function set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the module. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_luminosity']={syn:'Changes the luminosity of the module informative leds.',lib:'module.set_luminosity()',pro:'function set_luminosity(<span id=pn>newval</span>)',cmt:'<p>Changes the luminosity of the module informative leds. The parameter is a value between 0 and 100. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the luminosity of the module informative leds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'module.set_userData()',pro:'function set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Module']['set_userVar']={syn:'Returns the value previously stored in this attribute.',lib:'module.set_userVar()',pro:'function set_userVar(<span id=pn>newval</span>)',cmt:'<p>Returns the value previously stored in this attribute. On startup and after a device reboot, the value is always reset to zero.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['triggerFirmwareUpdate']={syn:'Schedules a module reboot into special firmware update mode.',lib:'module.triggerFirmwareUpdate()',pro:'function triggerFirmwareUpdate(<span id=pn>secBeforeReboot</span>)',cmt:'<p>Schedules a module reboot into special firmware update mode.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['updateFirmware']={syn:'Prepares a firmware update of the module.',lib:'module.updateFirmware()',pro:'function updateFirmware(<span id=pn>path</span>)',cmt:'<p>Prepares a firmware update of the module. This method returns a <tt>YFirmwareUpdate</tt> object which handles the firmware update process.</p>',par:{path:'the path of the byn file to use.'},ret:': A <tt>YFirmwareUpdate</tt> object or NULL on error.'};
//--- (end of generated code: Module)
//--- (generated code: OsControl)
doc['OsControl']={'':{syn:'OS control',inc:'import YOsControl from &#039;lib/oscontrol&#039;',cmt:'<p>The OScontrol object allows some control over the operating system running a VirtualHub. OsControl is available on the VirtualHub software only. This feature must be activated at the VirtualHub start up with -o option.</p>'}};
doc['OsControl']['FindOsControl']={syn:'Retrieves OS control for a given identifier.',lib:'YOsControl.FindOsControl()',pro:'function FindOsControl(<span id=pn>func</span>, <span id=pn>obj_yapi</span>, <span id=pn>YAPI</span>)',cmt:'<p>Retrieves OS control for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the OS control is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YOsControl.isOnline()</tt> to test if the OS control is indeed online at a given time. In case of ambiguity when looking for OS control by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the OS control'},ret:'a <tt>YOsControl</tt> object allowing you to drive the OS control.'};
doc['OsControl']['FirstOsControl']={syn:'Starts the enumeration of OS control currently accessible.',lib:'YOsControl.FirstOsControl()',pro:'function FirstOsControl(<span id=pn>obj_yapi</span>, <span id=pn>YAPI</span>)',cmt:'<p>Starts the enumeration of OS control currently accessible. Use the method <tt>YOsControl.nextOsControl()</tt> to iterate on next OS control.</p>',ret:'a pointer to a <tt>YOsControl</tt> object, corresponding to the first OS control currently online, or a <tt>null</tt> pointer if there are none.'};
doc['OsControl']['clearCache']={syn:'Invalidates the cache.',lib:'oscontrol.clearCache()',pro:'function clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the OS control attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['OsControl']['describe']={syn:'Returns a short text that describes unambiguously the instance of the OS control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'oscontrol.describe()',pro:'function describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the OS control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the OS control (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['OsControl']['get_advertisedValue']={syn:'Returns the current value of the OS control (no more than 6 characters).',lib:'oscontrol.get_advertisedValue()',pro:'function get_advertisedValue()',cmt:'<p>Returns the current value of the OS control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the OS control (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['OsControl']['get_errorMessage']={syn:'Returns the error message of the latest error with the OS control.',lib:'oscontrol.get_errorMessage()',pro:'function get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the OS control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the OS control object'};
doc['OsControl']['get_errorType']={syn:'Returns the numerical error code of the latest error with the OS control.',lib:'oscontrol.get_errorType()',pro:'function get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the OS control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the OS control object'};
doc['OsControl']['get_friendlyName']={syn:'Returns a global identifier of the OS control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'oscontrol.get_friendlyName()',pro:'function get_friendlyName()',cmt:'<p>Returns a global identifier of the OS control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the OS control if they are defined, otherwise the serial number of the module and the hardware identifier of the OS control (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the OS control using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['OsControl']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'oscontrol.get_functionDescriptor()',pro:'function get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['OsControl']['get_functionId']={syn:'Returns the hardware identifier of the OS control, without reference to the module.',lib:'oscontrol.get_functionId()',pro:'function get_functionId()',cmt:'<p>Returns the hardware identifier of the OS control, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the OS control (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['OsControl']['get_hardwareId']={syn:'Returns the unique hardware identifier of the OS control in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'oscontrol.get_hardwareId()',pro:'function get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the OS control in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the OS control (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the OS control (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['OsControl']['get_logicalName']={syn:'Returns the logical name of the OS control.',lib:'oscontrol.get_logicalName()',pro:'function get_logicalName()',cmt:'<p>Returns the logical name of the OS control.</p>',ret:'a string corresponding to the logical name of the OS control.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['OsControl']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'oscontrol.get_module()',pro:'function get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['OsControl']['get_shutdownCountdown']={syn:'Returns the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled.',lib:'oscontrol.get_shutdownCountdown()',pro:'function get_shutdownCountdown()',cmt:'<p>Returns the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled.</p>',ret:'an integer corresponding to the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled',ext:'On failure, throws an exception or returns <tt>Y_SHUTDOWNCOUNTDOWN_INVALID</tt>.'};
doc['OsControl']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'oscontrol.get_userData()',pro:'function get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['OsControl']['isOnline']={syn:'Checks if the OS control is currently reachable, without raising any error.',lib:'oscontrol.isOnline()',pro:'function isOnline()',cmt:'<p>Checks if the OS control is currently reachable, without raising any error. If there is a cached value for the OS control in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the OS control.</p>',ret:'<tt>true</tt> if the OS control can be reached, and <tt>false</tt> otherwise'};
doc['OsControl']['load']={syn:'Preloads the OS control cache with a specified validity duration.',lib:'oscontrol.load()',pro:'function load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the OS control cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['OsControl']['muteValueCallbacks']={syn:'Disable the propagation of every new advertised value to the parent hub.',lib:'oscontrol.muteValueCallbacks()',pro:'function muteValueCallbacks()',cmt:'<p>Disable the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['OsControl']['nextOsControl']={syn:'Continues the enumeration of OS control started using <tt>yFirstOsControl()</tt>.',lib:'oscontrol.nextOsControl()',pro:'function nextOsControl()',cmt:'<p>Continues the enumeration of OS control started using <tt>yFirstOsControl()</tt>.</p>',ret:'a pointer to a <tt>YOsControl</tt> object, corresponding to OS control currently online, or a <tt>null</tt> pointer if there are no more OS control to enumerate.'};
doc['OsControl']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'oscontrol.registerValueCallback()',pro:'function registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['OsControl']['set_logicalName']={syn:'Changes the logical name of the OS control.',lib:'oscontrol.set_logicalName()',pro:'function set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the OS control. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the OS control.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['OsControl']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'oscontrol.set_userData()',pro:'function set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['OsControl']['shutdown']={syn:'Schedules an OS shutdown after a given number of seconds.',lib:'oscontrol.shutdown()',pro:'function shutdown(<span id=pn>secBeforeShutDown</span>)',cmt:'<p>Schedules an OS shutdown after a given number of seconds.</p>',par:{secBeforeShutDown:'number of seconds before shutdown'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['OsControl']['unmuteValueCallbacks']={syn:'Re-enable the propagation of every new advertised value to the parent hub.',lib:'oscontrol.unmuteValueCallbacks()',pro:'function unmuteValueCallbacks()',cmt:'<p>Re-enable the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: OsControl)
//--- (generated code: Network)
doc['Network']={'':{syn:'Network function interface',inc:'import YNetwork from &#039;lib/network&#039;',cmt:'<p>YNetwork objects provide access to TCP/IP parameters of Yoctopuce modules that include a built-in network interface.</p>'}};
doc['Network']['FindNetwork']={syn:'Retrieves a network interface for a given identifier.',lib:'YNetwork.FindNetwork()',pro:'function FindNetwork(<span id=pn>func</span>, <span id=pn>obj_yapi</span>, <span id=pn>YAPI</span>)',cmt:'<p>Retrieves a network interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the network interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YNetwork.isOnline()</tt> to test if the network interface is indeed online at a given time. In case of ambiguity when looking for a network interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the network interface'},ret:'a <tt>YNetwork</tt> object allowing you to drive the network interface.'};
doc['Network']['FirstNetwork']={syn:'Starts the enumeration of network interfaces currently accessible.',lib:'YNetwork.FirstNetwork()',pro:'function FirstNetwork(<span id=pn>obj_yapi</span>, <span id=pn>YAPI</span>)',cmt:'<p>Starts the enumeration of network interfaces currently accessible. Use the method <tt>YNetwork.nextNetwork()</tt> to iterate on next network interfaces.</p>',ret:'a pointer to a <tt>YNetwork</tt> object, corresponding to the first network interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Network']['callbackLogin']={syn:'Connects to the notification callback and saves the credentials required to log into it.',lib:'network.callbackLogin()',pro:'function callbackLogin(<span id=pn>username</span>, <span id=pn>password</span>)',cmt:'<p>Connects to the notification callback and saves the credentials required to log into it. The password is not stored into the module, only a hashed copy of the credentials are saved. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{username:'username required to log to the callback',password:'password required to log to the callback'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['clearCache']={syn:'Invalidates the cache.',lib:'network.clearCache()',pro:'function clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the network interface attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Network']['describe']={syn:'Returns a short text that describes unambiguously the instance of the network interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'network.describe()',pro:'function describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the network interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the network interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Network']['get_adminPassword']={syn:'Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.',lib:'network.get_adminPassword()',pro:'function get_adminPassword()',cmt:'<p>Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_ADMINPASSWORD_INVALID</tt>.'};
doc['Network']['get_advertisedValue']={syn:'Returns the current value of the network interface (no more than 6 characters).',lib:'network.get_advertisedValue()',pro:'function get_advertisedValue()',cmt:'<p>Returns the current value of the network interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the network interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Network']['get_callbackCredentials']={syn:'Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.',lib:'network.get_callbackCredentials()',pro:'function get_callbackCredentials()',cmt:'<p>Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.</p>',ret:'a string corresponding to a hashed version of the notification callback credentials if set, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKCREDENTIALS_INVALID</tt>.'};
doc['Network']['get_callbackEncoding']={syn:'Returns the encoding standard to use for representing notification values.',lib:'network.get_callbackEncoding()',pro:'function get_callbackEncoding()',cmt:'<p>Returns the encoding standard to use for representing notification values.</p>',ret:'a value among <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt>, <tt>Y_CALLBACKENCODING_YOCTO_API</tt>, <tt>Y_CALLBACKENCODING_JSON_NUM</tt>, <tt>Y_CALLBACKENCODING_EMONCMS</tt>, <tt>Y_CALLBACKENCODING_AZURE</tt> and <tt>Y_CALLBACKENCODING_INFLUXDB</tt> corresponding to the encoding standard to use for representing notification values',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKENCODING_INVALID</tt>.'};
doc['Network']['get_callbackMaxDelay']={syn:'Returns the maximum waiting time between two callback notifications, in seconds.',lib:'network.get_callbackMaxDelay()',pro:'function get_callbackMaxDelay()',cmt:'<p>Returns the maximum waiting time between two callback notifications, in seconds.</p>',ret:'an integer corresponding to the maximum waiting time between two callback notifications, in seconds',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMAXDELAY_INVALID</tt>.'};
doc['Network']['get_callbackMethod']={syn:'Returns the HTTP method used to notify callbacks for significant state changes.',lib:'network.get_callbackMethod()',pro:'function get_callbackMethod()',cmt:'<p>Returns the HTTP method used to notify callbacks for significant state changes.</p>',ret:'a value among <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> and <tt>Y_CALLBACKMETHOD_PUT</tt> corresponding to the HTTP method used to notify callbacks for significant state changes',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMETHOD_INVALID</tt>.'};
doc['Network']['get_callbackMinDelay']={syn:'Returns the minimum waiting time between two callback notifications, in seconds.',lib:'network.get_callbackMinDelay()',pro:'function get_callbackMinDelay()',cmt:'<p>Returns the minimum waiting time between two callback notifications, in seconds.</p>',ret:'an integer corresponding to the minimum waiting time between two callback notifications, in seconds',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMINDELAY_INVALID</tt>.'};
doc['Network']['get_callbackUrl']={syn:'Returns the callback URL to notify of significant state changes.',lib:'network.get_callbackUrl()',pro:'function get_callbackUrl()',cmt:'<p>Returns the callback URL to notify of significant state changes.</p>',ret:'a string corresponding to the callback URL to notify of significant state changes',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKURL_INVALID</tt>.'};
doc['Network']['get_defaultPage']={syn:'Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.',lib:'network.get_defaultPage()',pro:'function get_defaultPage()',cmt:'<p>Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.</p>',ret:'a string corresponding to the HTML page to serve for the URL \x22/\x22\x22 of the hub',ext:'On failure, throws an exception or returns <tt>Y_DEFAULTPAGE_INVALID</tt>.'};
doc['Network']['get_discoverable']={syn:'Returns the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).',lib:'network.get_discoverable()',pro:'function get_discoverable()',cmt:'<p>Returns the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).</p>',ret:'either <tt>Y_DISCOVERABLE_FALSE</tt> or <tt>Y_DISCOVERABLE_TRUE</tt>, according to the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol)',ext:'On failure, throws an exception or returns <tt>Y_DISCOVERABLE_INVALID</tt>.'};
doc['Network']['get_errorMessage']={syn:'Returns the error message of the latest error with the network interface.',lib:'network.get_errorMessage()',pro:'function get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the network interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the network interface object'};
doc['Network']['get_errorType']={syn:'Returns the numerical error code of the latest error with the network interface.',lib:'network.get_errorType()',pro:'function get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the network interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the network interface object'};
doc['Network']['get_friendlyName']={syn:'Returns a global identifier of the network interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'network.get_friendlyName()',pro:'function get_friendlyName()',cmt:'<p>Returns a global identifier of the network interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the network interface if they are defined, otherwise the serial number of the module and the hardware identifier of the network interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the network interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Network']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'network.get_functionDescriptor()',pro:'function get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Network']['get_functionId']={syn:'Returns the hardware identifier of the network interface, without reference to the module.',lib:'network.get_functionId()',pro:'function get_functionId()',cmt:'<p>Returns the hardware identifier of the network interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the network interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Network']['get_hardwareId']={syn:'Returns the unique hardware identifier of the network interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'network.get_hardwareId()',pro:'function get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the network interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the network interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the network interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Network']['get_httpPort']={syn:'Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.',lib:'network.get_httpPort()',pro:'function get_httpPort()',cmt:'<p>Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.</p>',ret:'an integer corresponding to the HTML page to serve for the URL \x22/\x22\x22 of the hub',ext:'On failure, throws an exception or returns <tt>Y_HTTPPORT_INVALID</tt>.'};
doc['Network']['get_ipAddress']={syn:'Returns the IP address currently in use by the device.',lib:'network.get_ipAddress()',pro:'function get_ipAddress()',cmt:'<p>Returns the IP address currently in use by the device. The address may have been configured statically, or provided by a DHCP server.</p>',ret:'a string corresponding to the IP address currently in use by the device',ext:'On failure, throws an exception or returns <tt>Y_IPADDRESS_INVALID</tt>.'};
doc['Network']['get_logicalName']={syn:'Returns the logical name of the network interface.',lib:'network.get_logicalName()',pro:'function get_logicalName()',cmt:'<p>Returns the logical name of the network interface.</p>',ret:'a string corresponding to the logical name of the network interface.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Network']['get_macAddress']={syn:'Returns the MAC address of the network interface.',lib:'network.get_macAddress()',pro:'function get_macAddress()',cmt:'<p>Returns the MAC address of the network interface. The MAC address is also available on a sticker on the module, in both numeric and barcode forms.</p>',ret:'a string corresponding to the MAC address of the network interface',ext:'On failure, throws an exception or returns <tt>Y_MACADDRESS_INVALID</tt>.'};
doc['Network']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'network.get_module()',pro:'function get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Network']['get_ntpServer']={syn:'Returns the IP address of the NTP server to be used by the device.',lib:'network.get_ntpServer()',pro:'function get_ntpServer()',cmt:'<p>Returns the IP address of the NTP server to be used by the device.</p>',ret:'a string corresponding to the IP address of the NTP server to be used by the device',ext:'On failure, throws an exception or returns <tt>Y_NTPSERVER_INVALID</tt>.'};
doc['Network']['get_poeCurrent']={syn:'Returns the current consumed by the module from Power-over-Ethernet (PoE), in milli-amps.',lib:'network.get_poeCurrent()',pro:'function get_poeCurrent()',cmt:'<p>Returns the current consumed by the module from Power-over-Ethernet (PoE), in milli-amps. The current consumption is measured after converting PoE source to 5 Volt, and should never exceed 1800 mA.</p>',ret:'an integer corresponding to the current consumed by the module from Power-over-Ethernet (PoE), in milli-amps',ext:'On failure, throws an exception or returns <tt>Y_POECURRENT_INVALID</tt>.'};
doc['Network']['get_primaryDNS']={syn:'Returns the IP address of the primary name server to be used by the module.',lib:'network.get_primaryDNS()',pro:'function get_primaryDNS()',cmt:'<p>Returns the IP address of the primary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the primary name server to be used by the module',ext:'On failure, throws an exception or returns <tt>Y_PRIMARYDNS_INVALID</tt>.'};
doc['Network']['get_readiness']={syn:'Returns the current established working mode of the network interface.',lib:'network.get_readiness()',pro:'function get_readiness()',cmt:'<p>Returns the current established working mode of the network interface. Level zero (DOWN_0) means that no hardware link has been detected. Either there is no signal on the network cable, or the selected wireless access point cannot be detected. Level 1 (LIVE_1) is reached when the network is detected, but is not yet connected. For a wireless network, this shows that the requested SSID is present. Level 2 (LINK_2) is reached when the hardware connection is established. For a wired network connection, level 2 means that the cable is attached at both ends. For a connection to a wireless access point, it shows that the security parameters are properly configured. For an ad-hoc wireless connection, it means that there is at least one other device connected on the ad-hoc network. Level 3 (DHCP_3) is reached when an IP address has been obtained using DHCP. Level 4 (DNS_4) is reached when the DNS server is reachable on the network. Level 5 (WWW_5) is reached when global connectivity is demonstrated by properly loading the current time from an NTP server.</p>',ret:'a value among <tt>Y_READINESS_DOWN</tt>, <tt>Y_READINESS_EXISTS</tt>, <tt>Y_READINESS_LINKED</tt>, <tt>Y_READINESS_LAN_OK</tt> and <tt>Y_READINESS_WWW_OK</tt> corresponding to the current established working mode of the network interface',ext:'On failure, throws an exception or returns <tt>Y_READINESS_INVALID</tt>.'};
doc['Network']['get_router']={syn:'Returns the IP address of the router on the device subnet (default gateway).',lib:'network.get_router()',pro:'function get_router()',cmt:'<p>Returns the IP address of the router on the device subnet (default gateway).</p>',ret:'a string corresponding to the IP address of the router on the device subnet (default gateway)',ext:'On failure, throws an exception or returns <tt>Y_ROUTER_INVALID</tt>.'};
doc['Network']['get_secondaryDNS']={syn:'Returns the IP address of the secondary name server to be used by the module.',lib:'network.get_secondaryDNS()',pro:'function get_secondaryDNS()',cmt:'<p>Returns the IP address of the secondary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the secondary name server to be used by the module',ext:'On failure, throws an exception or returns <tt>Y_SECONDARYDNS_INVALID</tt>.'};
doc['Network']['get_subnetMask']={syn:'Returns the subnet mask currently used by the device.',lib:'network.get_subnetMask()',pro:'function get_subnetMask()',cmt:'<p>Returns the subnet mask currently used by the device.</p>',ret:'a string corresponding to the subnet mask currently used by the device',ext:'On failure, throws an exception or returns <tt>Y_SUBNETMASK_INVALID</tt>.'};
doc['Network']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'network.get_userData()',pro:'function get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Network']['get_userPassword']={syn:'Returns a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise.',lib:'network.get_userPassword()',pro:'function get_userPassword()',cmt:'<p>Returns a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_USERPASSWORD_INVALID</tt>.'};
doc['Network']['get_wwwWatchdogDelay']={syn:'Returns the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity.',lib:'network.get_wwwWatchdogDelay()',pro:'function get_wwwWatchdogDelay()',cmt:'<p>Returns the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity. A zero value disables automated reboot in case of Internet connectivity loss.</p>',ret:'an integer corresponding to the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity',ext:'On failure, throws an exception or returns <tt>Y_WWWWATCHDOGDELAY_INVALID</tt>.'};
doc['Network']['isOnline']={syn:'Checks if the network interface is currently reachable, without raising any error.',lib:'network.isOnline()',pro:'function isOnline()',cmt:'<p>Checks if the network interface is currently reachable, without raising any error. If there is a cached value for the network interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the network interface.</p>',ret:'<tt>true</tt> if the network interface can be reached, and <tt>false</tt> otherwise'};
doc['Network']['load']={syn:'Preloads the network interface cache with a specified validity duration.',lib:'network.load()',pro:'function load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the network interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['muteValueCallbacks']={syn:'Disable the propagation of every new advertised value to the parent hub.',lib:'network.muteValueCallbacks()',pro:'function muteValueCallbacks()',cmt:'<p>Disable the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['nextNetwork']={syn:'Continues the enumeration of network interfaces started using <tt>yFirstNetwork()</tt>.',lib:'network.nextNetwork()',pro:'function nextNetwork()',cmt:'<p>Continues the enumeration of network interfaces started using <tt>yFirstNetwork()</tt>.</p>',ret:'a pointer to a <tt>YNetwork</tt> object, corresponding to a network interface currently online, or a <tt>null</tt> pointer if there are no more network interfaces to enumerate.'};
doc['Network']['ping']={syn:'Pings str_host to test the network connectivity.',lib:'network.ping()',pro:'function ping(<span id=pn>host</span>)',cmt:'<p>Pings str_host to test the network connectivity. Sends four ICMP ECHO_REQUEST requests from the module to the target str_host. This method returns a string with the result of the 4 ICMP ECHO_REQUEST requests.</p>',par:{host:'the hostname or the IP address of the target'},ret:'a string with the result of the ping.'};
doc['Network']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'network.registerValueCallback()',pro:'function registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Network']['set_adminPassword']={syn:'Changes the password for the \x22admin\x22 user.',lib:'network.set_adminPassword()',pro:'function set_adminPassword(<span id=pn>newval</span>)',cmt:'<p>Changes the password for the \x22admin\x22 user. This password becomes instantly required to perform any change of the module state. If the specified value is an empty string, a password is not required anymore. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the password for the \x22admin\x22 user'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackCredentials']={syn:'Changes the credentials required to connect to the callback address.',lib:'network.set_callbackCredentials()',pro:'function set_callbackCredentials(<span id=pn>newval</span>)',cmt:'<p>Changes the credentials required to connect to the callback address. The credentials must be provided as returned by function <tt>get_callbackCredentials</tt>, in the form <tt>username:hash</tt>. The method used to compute the hash varies according to the the authentication scheme implemented by the callback, For Basic authentication, the hash is the MD5 of the string <tt>username:password</tt>. For Digest authentication, the hash is the MD5 of the string <tt>username:realm:password</tt>. For a simpler way to configure callback credentials, use function <tt>callbackLogin</tt> instead. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the credentials required to connect to the callback address'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackEncoding']={syn:'Changes the encoding standard to use for representing notification values.',lib:'network.set_callbackEncoding()',pro:'function set_callbackEncoding(<span id=pn>newval</span>)',cmt:'<p>Changes the encoding standard to use for representing notification values.</p>',par:{newval:'a value among <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt>, <tt>Y_CALLBACKENCODING_YOCTO_API</tt>, <tt>Y_CALLBACKENCODING_JSON_NUM</tt>, <tt>Y_CALLBACKENCODING_EMONCMS</tt>, <tt>Y_CALLBACKENCODING_AZURE</tt> and <tt>Y_CALLBACKENCODING_INFLUXDB</tt> corresponding to the encoding standard to use for representing notification values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMaxDelay']={syn:'Changes the maximum waiting time between two callback notifications, in seconds.',lib:'network.set_callbackMaxDelay()',pro:'function set_callbackMaxDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the maximum waiting time between two callback notifications, in seconds.</p>',par:{newval:'an integer corresponding to the maximum waiting time between two callback notifications, in seconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMethod']={syn:'Changes the HTTP method used to notify callbacks for significant state changes.',lib:'network.set_callbackMethod()',pro:'function set_callbackMethod(<span id=pn>newval</span>)',cmt:'<p>Changes the HTTP method used to notify callbacks for significant state changes.</p>',par:{newval:'a value among <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> and <tt>Y_CALLBACKMETHOD_PUT</tt> corresponding to the HTTP method used to notify callbacks for significant state changes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMinDelay']={syn:'Changes the minimum waiting time between two callback notifications, in seconds.',lib:'network.set_callbackMinDelay()',pro:'function set_callbackMinDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the minimum waiting time between two callback notifications, in seconds.</p>',par:{newval:'an integer corresponding to the minimum waiting time between two callback notifications, in seconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackUrl']={syn:'Changes the callback URL to notify significant state changes.',lib:'network.set_callbackUrl()',pro:'function set_callbackUrl(<span id=pn>newval</span>)',cmt:'<p>Changes the callback URL to notify significant state changes. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the callback URL to notify significant state changes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_defaultPage']={syn:'Changes the default HTML page returned by the hub.',lib:'network.set_defaultPage()',pro:'function set_defaultPage(<span id=pn>newval</span>)',cmt:'<p>Changes the default HTML page returned by the hub. If not value are set the hub return \x22index.html\x22 which is the web interface of the hub. It is possible de change this page for file that has been uploaded on the hub.</p>',par:{newval:'a string corresponding to the default HTML page returned by the hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_discoverable']={syn:'Changes the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).',lib:'network.set_discoverable()',pro:'function set_discoverable(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).</p>',par:{newval:'either <tt>Y_DISCOVERABLE_FALSE</tt> or <tt>Y_DISCOVERABLE_TRUE</tt>, according to the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_httpPort']={syn:'Changes the default HTML page returned by the hub.',lib:'network.set_httpPort()',pro:'function set_httpPort(<span id=pn>newval</span>)',cmt:'<p>Changes the default HTML page returned by the hub. If not value are set the hub return \x22index.html\x22 which is the web interface of the hub. It is possible de change this page for file that has been uploaded on the hub.</p>',par:{newval:'an integer corresponding to the default HTML page returned by the hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_logicalName']={syn:'Changes the logical name of the network interface.',lib:'network.set_logicalName()',pro:'function set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the network interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the network interface.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_ntpServer']={syn:'Changes the IP address of the NTP server to be used by the module.',lib:'network.set_ntpServer()',pro:'function set_ntpServer(<span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the NTP server to be used by the module. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the NTP server to be used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_primaryDNS']={syn:'Changes the IP address of the primary name server to be used by the module.',lib:'network.set_primaryDNS()',pro:'function set_primaryDNS(<span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the primary name server to be used by the module. When using DHCP, if a value is specified, it overrides the value received from the DHCP server. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the primary name server to be used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_secondaryDNS']={syn:'Changes the IP address of the secondary name server to be used by the module.',lib:'network.set_secondaryDNS()',pro:'function set_secondaryDNS(<span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the secondary name server to be used by the module. When using DHCP, if a value is specified, it overrides the value received from the DHCP server. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the secondary name server to be used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'network.set_userData()',pro:'function set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Network']['set_userPassword']={syn:'Changes the password for the \x22user\x22 user.',lib:'network.set_userPassword()',pro:'function set_userPassword(<span id=pn>newval</span>)',cmt:'<p>Changes the password for the \x22user\x22 user. This password becomes instantly required to perform any use of the module. If the specified value is an empty string, a password is not required anymore. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the password for the \x22user\x22 user'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_wwwWatchdogDelay']={syn:'Changes the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity.',lib:'network.set_wwwWatchdogDelay()',pro:'function set_wwwWatchdogDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity. A zero value disables automated reboot in case of Internet connectivity loss. The smallest valid non-zero timeout is 90 seconds.</p>',par:{newval:'an integer corresponding to the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['unmuteValueCallbacks']={syn:'Re-enable the propagation of every new advertised value to the parent hub.',lib:'network.unmuteValueCallbacks()',pro:'function unmuteValueCallbacks()',cmt:'<p>Re-enable the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['useDHCP']={syn:'Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server.',lib:'network.useDHCP()',pro:'function useDHCP(<span id=pn>fallbackIpAddr</span>, <span id=pn>fallbackSubnetMaskLen</span>, <span id=pn>fallbackRouter</span>)',cmt:'<p>Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server. Until an address is received from a DHCP server, the module uses the IP parameters specified to this function. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{fallbackIpAddr:'fallback IP address, to be used when no DHCP reply is received',fallbackSubnetMaskLen:'fallback subnet mask length when no DHCP reply is received, as an integer (eg. 24 means 255.255.255.0)',fallbackRouter:'fallback router IP address, to be used when no DHCP reply is received'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['useStaticIP']={syn:'Changes the configuration of the network interface to use a static IP address.',lib:'network.useStaticIP()',pro:'function useStaticIP(<span id=pn>ipAddress</span>, <span id=pn>subnetMaskLen</span>, <span id=pn>router</span>)',cmt:'<p>Changes the configuration of the network interface to use a static IP address. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ipAddress:'device IP address',subnetMaskLen:'subnet mask length, as an integer (eg. 24 means 255.255.255.0)',router:'router IP address (default gateway)'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Network)
//--- (end of generated code)

 function isClassMethod(str_method)
 { return str_method.charAt(0) == str_method.charAt(0).toUpperCase();
 }

 // add function aliases to the substitution list
 for(classname in doc)
 { for(funcname in doc[classname])
   { if(isClassMethod(funcname))
     { // class method, generate shortcut
       sub['y'+funcname] = doc[classname][funcname].lib;
     }
   }
 }

 function ApplySub(text,classname)
 { var pos, endpos = 0, key, rep;
   if(sub['null'] != 'null') text = text.replace('<tt>null</tt>','<tt>'+sub['null']+'</tt>');
   if(UseShortcuts) return text;
   if(classname.substr(0,1)!='Y') classname = 'Y'+classname;
   while((pos = text.toLowerCase().indexOf('<tt>',endpos)) >= endpos) {
       pos += 4;
       endpos = text.indexOf('</', pos);
       key = text.substr(pos,endpos-pos).match(/[\w_]+/);
       if(key)
       { key = key[0];
         rep = sub[key];
         if(!rep && key.substr(0,2)=='Y_' && sub['YAPI_SUCCESS']) {
           rep = sub['YAPI_SUCCESS'].replace('YAPI',classname).replace('SUCCESS',key.substr(2,key.length));
         }
         if(rep) text = text.substr(0, pos)+rep+text.substr(endpos);
       }
   }
   return text;
 }

 function SetPosition(o,x,y)
 { var it=document.getElementById(o);
   if (!it) throw  "SetPosition: "+o+" element does not exist."
   it.style.top  = y;
   it.style.left  = x;
 }

function GetPositionX(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionX: "+o+" element does not exist."
   return parseInt(it.style.left);
 }

function GetPositionY(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionY: "+o+" element does not exist."
   return parseInt(it.style.top);
 }

function  GetWidth(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetWidth: "+o+" element does not exist."
    return parseInt(it.style.width);
 }

function  GetHeight(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetHeight: "+o+" element does not exist."
    return parseInt(it.style.height);
 }

function  SetHeight(o,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetHeight: "+o+" element does not exist."
    h=parseInt(h);
    if (h<0) h=0;
	it.style.height  =  h+ "px";
 }

function  SetWidth(o,w)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetWidth: "+o+" element does not exist."
    w = parseInt(w);
    if (w<0) w=0;
	it.style.width  = parseInt(w) + "px";
 }

function  SetLeft(o,l)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetLeft: "+o+" element does not exist."
    it.style.left  = parseInt(l) + "px";
 }

function  SetTop(o,t)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetTop: "+o+" element does not exist."
    it.style.top  = parseInt(t) + "px";
 }

function  SetSize(o,w,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetSize: "+o+" element does not exist."
    w= parseInt(w);
    if (w<0) w=0;
    h=parseInt(h);
    if (h<0) h=0;
    it.style.width   = w;
	it.style.height  = h;
 }

function  GetWindowWidth()
 {	 return parseInt(document.body.clientWidth);
 }

function  GetWindowHeight()
 {	 return parseInt(document.body.clientHeight);
 }

function computeWinWH()
 { WinW             = GetWindowWidth() ;
   if (WinW<600) WinW=600;
   WinH             = GetWindowHeight();
   if (WinH<400) WinH=400;
}


 function getInnerHeight()
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollHeight, D.documentElement.scrollHeight),
        Math.max(D.body.offsetHeight, D.documentElement.offsetHeight),
        Math.max(D.body.clientHeight, D.documentElement.clientHeight)
    );
 }

 function getInnerWidth()
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollWidth, D.documentElement.scrollWidth),
        Math.max(D.body.offsetWidth, D.documentElement.offsetWidth),
        Math.max(D.body.clientWidth, D.documentElement.clientWidth)
    );

 }

function onResize(fct)
  { fct();
    resizeCallBacks[resizeCallBacks.length]=fct;
  }

function windowResized()
  { computeWinWH()
    for (var i=0;i<resizeCallBacks.length;i++)
      resizeCallBacks[i]();
  }

function jsQuote(str_in)
{ str_in = str_in+'';
  var str_out   = '';
  for (i=0;i<str_in.length;i++)
   {
     var ascii = str_in.charCodeAt(i);
     if ((ascii>=32)&&(ascii<=127)&&(ascii!=34)&&(ascii!=39)) str_out =str_out+str_in.charAt(i);
     else
      { var hex = ascii.toString(16).toUpperCase();
        if (hex.length==1) hex = '0'+hex;
        str_out = str_out + String.fromCharCode(92) + 'x'+ hex;
      }
   }
   return str_out;
  }


function resizeMargin()
 {
   SetSize("MarginLayer",marginSize,WinH-110);
   SetLeft("FunctionsLayer",marginSize);
   SetSize("FunctionsLayer",WinW-marginSize,WinH-110);
 }

function resizeSeparator()
 { SetHeight("separatorLayer",WinH-110);
 }

function positionObject(int_x,int_y)
 { this.x = int_x;
   this.y = int_y;
 }

function GetEventPosition(event)
 { var x,y;
   if (event.changedTouches)
    { x = event.changedTouches[0].pageX;
      y = event.changedTouches[0].pageY;
    }
   else
    {  x = event.PageX;
       y = event.PageY;
      if (!x)
        { x= event.clientX + document.body.scrollLeft;
         y= event.clientY + document.body.scrollTop;
        }
    }
  return new positionObject(x,y);
 }


function EnableDrag(var_element,onDragMove,onDragEnd)
  {
   //onDragMove & onDragMove are optinnals callbacks fct(DomElement,position) where position is an associtative array "x","y
   if (document.addEventListener)
      { var_element.addEventListener("mousedown",Drag_start,false);
        var_element.addEventListener("touchstart",Drag_start,false);
      }
   else
     if (document.attachEvent)
       var_element.attachEvent("onmousedown",Drag_start);

   if (onDragMove)  var_element.onDragMove = onDragMove;
   if (onDragEnd)   var_element.onDragEnd  = onDragEnd;
  }

 var LastDraggedObject = null;

 function DraggedObject(obj_element,obj_elmtInitialPos,obj_mouseInitalPos)
  {this.element         = obj_element;
   this.elmtInitialPos  = obj_elmtInitialPos;
   this.elmtCurrentPos  = new positionObject(obj_elmtInitialPos.x,obj_elmtInitialPos.y);
   this.mouseInitialPos = obj_mouseInitalPos;
  }

function Drag_start(event)
 {
   if (!event) event = window.event;
   var source = event.srcElement;

   if (event.button!=undefined)
    { if ((event.button!=1) && (document.attachEvent)) return;  // ie;
      if ((event.button!=0) && (document.addEventListener)) return;  // other;
    }

   if (!source) source= this;
   if (!source) return;
   var originalsource=source;
   while (source.tagName!="DIV")
      { if (source.tagName=="A") return false;  // there is a link (a probably a button) on the way:  cancel drag
        source=source.parentNode;
      }

   if (event.preventDefault)   event.preventDefault();
   source.style.cursor="col-resize";
   lastDraggedObject      = new DraggedObject( source,
                                               new positionObject(parseInt(source.style.left),parseInt(source.style.top)),
                                               GetEventPosition(event)
                                              );
   if (document.addEventListener)
    { document.addEventListener("mousemove",Drag_mouseCapture,false);
      document.addEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.addEventListener("touchmove",Drag_mouseCapture,false);
      document.addEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.attachEvent)
    { document.attachEvent("onmousemove",Drag_mouseCapture);
      document.attachEvent("onmouseup",Drag_stopMouseCapture);
    }
   document.onmouseup   =   Drag_stopMouseCapture;
 }


function Drag_mouseCapture(event)
 {
   if (!event) event = window.event;
   var position = GetEventPosition(event);
   if (event.preventDefault) event.preventDefault();


   var x = (lastDraggedObject.elmtInitialPos.x + position.x -  lastDraggedObject.mouseInitialPos.x);
   var y = (lastDraggedObject.elmtInitialPos.y + position.y -  lastDraggedObject.mouseInitialPos.y);

   var iw = getInnerWidth()
   var ih = getInnerHeight();
   var w  = lastDraggedObject.element.offsetWidth;
   var h  = lastDraggedObject.element.offsetHeight;

   if (x>iw-w) x=iw-w;
   if (y>ih-h) y=ih-h;
   if (x<0) x=0;
   if (y<0) y=0;

   var p = {x:x,y:y};

   if (lastDraggedObject.element.onDragMove)
      lastDraggedObject.element.onDragMove(lastDraggedObject.element,p);

   lastDraggedObject.elmtCurrentPos.x   = p.x;
   lastDraggedObject.elmtCurrentPos.y   = p.y;

   lastDraggedObject.element.style.left = p.x+"px";
   lastDraggedObject.element.style.top  = p.y+"px";
 }

function Drag_stopMouseCapture()
 {
   if (document.removeEventListener)
    { document.removeEventListener("mousemove",Drag_mouseCapture,false);
      document.removeEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.removeEventListener("touchmove",Drag_mouseCapture,false);
      document.removeEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.detachEvent)
    { document.detachEvent("onmousemove",Drag_mouseCapture);
      document.detachEvent("onmouseup",Drag_stopMouseCapture);
    }

  if (lastDraggedObject)
    { lastDraggedObject.element.style.cursor='col-resize';
      if (lastDraggedObject.element.onDragEnd)
       lastDraggedObject.element.onDragEnd(lastDraggedObject.element,{x:lastDraggedObject.elmtCurrentPos.x,y:lastDraggedObject.elmtCurrentPos.y});
    }
   lastDraggedObject = null;
 }

 function marginMove(el,pos)
  {pos.y = 80;
   if (pos.x<100) pos.x=100;
   if (pos.x>WinW-100) pos.x=WinW-100;
   marginSize=pos.x;
   resizeMargin()
  }

 function proto(str_classindex, m)
  {
      var funcproto = doc[str_classindex][m].pro;
      if(isClassMethod(m)) {
          if(UseShortcuts) {
              funcproto = funcproto.replace(m, 'y'+m);
          } else if(doc[str_classindex][m].lib.substr(0,1) == '[' && funcproto.substr(0,1) != '+') {
              var params = doc[str_classindex][m].par;
              var methodpos = funcproto.search(m);
              var endrettype = methodpos;
              while(endrettype > 0 && funcproto.substr(endrettype-1,1)==' ') endrettype--;
              var newproto = "+("+funcproto.substr(0,endrettype)+") "+m;
              var pos = methodpos+m.length;
              for(var p in params) {
                  pos += funcproto.slice(pos).search(/[A-Za-z]/);
                  var argpos = pos + funcproto.slice(pos).search('<span');
                  var endargtype = argpos;
                  while(endargtype > pos && funcproto.substr(endargtype-1,1)==' ') endargtype--;
                  var endarg = argpos + funcproto.slice(argpos).search(/[,)]/);
                  newproto += ": ("+funcproto.slice(pos, endargtype)+") "+funcproto.slice(argpos,endarg)+" ";
                  pos = endarg;
              }
              funcproto = newproto;
          }
      }
      return funcproto
  }

 var lastindex_shown = "";
 var lastname_shown = null;
 function Show(str_classindex,str_name)
  {
    if ((str_classindex=='')&&(str_name==''))
      { document.getElementById("FunctionsLayerInner").innerHTML =NotFound;
        return;
      }

    var fcthtml='';
    fcthtml = "";
    lastindex_shown =str_classindex;
    if (str_name)
       { lastname_shown = str_name;
         var fct = doc[str_classindex][str_name];
         var funcname = fct.lib;
         var funcproto = proto(str_classindex, str_name);
         if(UseShortcuts && isClassMethod(str_name)) {
             funcname = 'y'+str_name+'()';
         }
         fcthtml = "<span class='funcHeader'>"+funcname+'</span>'
                   +"<br><br><span class='prototype'>"+funcproto+'</span>'
                   +'<br><br>'+ApplySub(fct.cmt,str_classindex);
         if (fct.par)
          {  fcthtml += "<span class='paramAndRet'>"+ParamLabel+'</span><br>\n';
             fcthtml +='<table class="paramtable">'
             for (var p in  fct.par)
                 fcthtml +='<tr><td class="pn">'+p+'</td><td> : '+ApplySub(fct.par[p],str_classindex)+'</td></tr>\n';
             fcthtml +='</table><br>'
          }

         if (fct.ret)
          { fcthtml += "<span class='paramAndRet'>"+ReturnLabel+'</span><br>\n';
            fcthtml +='<p class="paramtable">'+ApplySub(fct.ret,str_classindex)+'</p>\n';
          }

         if (fct.ext)  fcthtml+=ApplySub(fct.ext,str_classindex);
      }
     else
     if (str_classindex!='')
     {  fcthtml = "<span class='funcHeader'>"+str_classindex+'</span><br>'
                + "<p>"+ApplySub(doc[str_classindex][''].syn,str_classindex)+"</p>"
                + "<p>"+IncludeLabel+"</p>"
                + "<p  class='include'>"+doc[str_classindex][''].inc+"</p>"
                + "<p>"+ApplySub(doc[str_classindex][''].cmt,str_classindex)+"</p>";
        for (m in doc[str_classindex]) {
          if (m!='') {
            var funcproto = proto(str_classindex, m);
            fcthtml +="<p class='methodlist'><a class='protoindex' href='javascript:Show(\""+str_classindex+"\",\""+m+"\")'>"+funcproto+'</a><br>'
                    +"<span class='synlist'>"+ApplySub(doc[str_classindex][m].syn,str_classindex)+'</span></p>';
          }
        }
     }
     document.getElementById("FunctionsLayerInner").innerHTML =  fcthtml;
  }

  function expand(source,openonly)
  { if (document.getElementById(source.id+"List").style.display=='' && !openonly)
     { document.getElementById(source.id+"List").style.display='none';
       document.getElementById(source.id).src=plusimage;
     }
    else
     { document.getElementById(source.id+"List").style.display='';
       document.getElementById(source.id).src=minusimage;
     }
  }

 function ShowFunctions(str_currentClassName)
  { var marginhtml = "";
    for (var classname in doc)
    {  var icon = plusimage;
       var fct  = "expand";
       var display = "none"
       if (str_currentClassName==classname)
         {  icon = minusimage;
            fct  = "expand";
            display = ""
        }
       marginhtml = marginhtml+"<span class='classheader'><img class='expandColapse' id='"+classname+"' onclick='"+fct+"(this)' src='"+icon+"'/> ";
       marginhtml = marginhtml+"<a href='javascript:Show(\""+classname+"\",\"\");' id='"+classname+"' onclick='"+fct+"(this,true)'>"+classname+'</a></span><br>';
       marginhtml = marginhtml+ "<div id='"+classname+"List' class='methodsList' style='display:"+display+"'>";

       for (var method in doc[classname])
       { if (method!='')
         { var funcname = doc[classname][method].lib;
           if(UseShortcuts && isClassMethod(method)) funcname = 'y'+method+'()';
           marginhtml = marginhtml+"<a id="+classname+'.'+method+" style='display:block' href='javascript:Show(\""+classname+"\",\""+method+"\");'>"+funcname+'</a>';
         }
       }
       marginhtml = marginhtml+'</div>'
    }

    document.getElementById("MarginLayer").innerHTML = marginhtml;
  }

 function fctMatch(classname,method,values)
  { var found    = new Array()
    var tosearch = new Array()

    for (var i=0;i<values.length;i++)
     if (values[i]!='' && values[i]!='y')
      { if(values[i].substr(0,3) == '[y]')
          tosearch[tosearch.length] = values[i].substr(3,values[i].length);
        else
          tosearch[tosearch.length] = values[i];
      }

    for (var i=0;i<tosearch.length;i++)
       {  var expr     = new RegExp(tosearch[i], "i");
          var fct = doc[classname][method]
          var found = classname.search(expr)>=0;
          if (!found) found=method.search(expr)>=0;

          if (!found && fct.inc)
            {if (!found && fct.syn) found=fct.syn.search(expr)>=0;
             if (!found) found=fct.inc.search(expr)>=0;
            }

          if (!found && fct.pro) found=fct.pro.search(expr)>=0;
          if (fct.par)
             for (var p in  fct.par)
              { if (!found) found=p.search(expr)>=0;
                if (!found) found=fct.par[p].search(expr)>=0;
              }
          if (fct.ret)
              { if (!found) found=fct.ret.search(expr)>=0;
              }
          if (!found && fct.cmt)found=fct.cmt.search(expr)>=0;
          if (!found && fct.ext)found=fct.ext.search(expr)>=0;

          if (!found) return false;
       }


    return true;

  }

 var searchTimer = null;

 function doSearch()
  { searchTimer = null;
    var value= document.forms['yoctoForm'].elements['search'].value;

    if (value=='')
     { for (var classname in doc)
        { var container = document.getElementById(classname+"List");
          for (var method in doc[classname])
           if (method!='')
             { var it = document.getElementById(classname+'.'+method);
               if (it) it.style.display="block";
             }
          document.getElementById(classname).style.visibility='visible';
          var container = document.getElementById(classname+"List");
          if (container["originalDisplay"]!="")
           { document.getElementById(classname+"List").style.display='none';
             document.getElementById(classname).src=plusimage;
           }
          else
           { document.getElementById(classname+"List").style.display='';
             document.getElementById(classname).src=minusimage;
           }
          container["originalDisplay"]=null;
        }
        Show(lastindex_shown,lastname_shown);
       return;
      }

    var firstindex = '';
    var firstname  = '';
    qvalue = value;
    value = '';
    for(var i = 0; i < qvalue.length; i++) {
        var c = qvalue.charAt(i);
        if(c == '\\' || c == '[' || c == ']' || c == '(' || c == ')') {
            value += '.';
        } else {
          if (c!=' ')  value+='['+qvalue.charAt(i)+']';
                   else value+=' ';
        }
    }
    for (var classname in doc)
     { var  matchfound=false;
       var container = document.getElementById(classname+"List");
       if (!container["originalDisplay"]) container["originalDisplay"]=null;
       if (container["originalDisplay"]==null) container["originalDisplay"] = container.style.display;
       values = value.split(' ');
       for (var method in doc[classname])

         { var it  = document.getElementById(classname+'.'+method);
           var match = fctMatch(classname,method,values);
               if (match)
                 {  if (it) it.style.display="block";
                     matchfound=true;
                    if (firstindex=='') {firstindex=classname; firstname = method;}
                 }
              else
                 { if (it) it.style.display="none";
                 }
         }

      if  (matchfound)
          { document.getElementById(classname+"List").style.display='';
            document.getElementById(classname).src=minusimage;
            document.getElementById(classname).style.visibility='visible';
          }
         else
          { document.getElementById(classname+"List").style.display='none';
            document.getElementById(classname).style.visibility='hidden';
            document.getElementById(classname).src=plusimage;
          }
     }

    Show(firstindex,firstname);


  }

 function initSearch()
  { if (searchTimer!=null)  clearTimeout(searchTimer);
    searchTimer = setTimeout('doSearch()',500);
  }

 function sortObject(o) {
    var sorted = {}, key, a = [];
    for (key in o) {
        if (key != 'YAPI' && o.hasOwnProperty(key)) {
                a.push(key);
        }
    }

    a.sort();
     if (o['YAPI']) sorted['YAPI']=o['YAPI'];
    for (key = 0; key < a.length; key++) {
        sorted[a[key]] = o[a[key]];
    }
    return sorted;
}

 function OOcheckboxChange()
  { UseShortcuts =  document.forms["yoctoForm"].elements["OOcheckbox"].checked;
    ShowFunctions(lastindex_shown);
    Show(lastindex_shown,lastname_shown);

  }




 -->
</SCRIPT>

</HEAD>

<BODY>

<div id="BannerLayer">
<table width=100% >
<tr><td rowspan=2>
<img alt="Yocto-Api :-)" style='margin-left:5px;'src="data:image/png;base64,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" />
</td><td style='vertical-align:top;text-align:right'>
<a class='extLink' href='http://www.yoctopuce.com'>www.yoctopuce.com</a>
</td>
</tr>
<tr><td  id='langdt'></td></TR>
</table>
</div>
<div id="MarginLayer"></div>
<div id="FunctionsLayer"><div id="FunctionsLayerInner"></div></div>
<div id="FooterLayer"><form name='yoctoForm'>
<table width=100% style='margin-top:3px;'>
<tr><td>
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAANwAAADcBYx2BhQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGgSURBVCiRjdC9a1NhFAbw8973ed7bewm859KKc4oFwUUwk0uMkICC4gfYIjSDQhaH+ge4BOFCwEUpQsCtEEkHURCHigQjcQo4FFyKHYWsflGaq9elStVr9Yzn4cf5MHmeS1G12+1gNBrdJLkMYIHkNoD+ZDLpDAaDzBRBY4yp1+tPSZ4los0QhzYEH0+RcgLAq3K5fLoQNhqNGwBWY3d85fBM+vxHf8fdPWnc5gOSt4KiNUkukuHb/UhEZGZ35TVs/MZau1gIrbXzLph7UZTBzL4EMF8IAWwZfjrz9duu+T0L3Ic6gK2/rboGmCM77vbF/Rizqw1SjgFY++M5lUqF4/F42mw2HwJYAsJ3sHMb5JcaKEcBPIvj+NwvsFqtni+VSj3vfb/X611vtVrXACxbaxecc9sk+51O536e5/lPWKvVLkRRtJ4kCVX1c5ZlSbfbnRadIiIS7E26FEXRuqpSVafe+6sHIREROxwOL8dx3FdVJkky9d5fSdP0yUFIRCQIw/CeqkJVM+/9Upqmj/+FREQCVb2jqu/30KP/QSIi3wFqcn4o9hAuDAAAAABJRU5ErkJggg==" />
<input name='search' onkeyup='initSearch()'></form>
</td><td id ='oosyntax' ></td><td id='version'>
</td>
</table>

</div>
<div id="separatorLayer" style='top:80px;left:250px'></div>

<SCRIPT type="text/JavaScript" >
<!--
document.getElementById('langdt').innerHTML = Language;
document.getElementById('version').innerHTML = Version;

computeWinWH();

onResize(function(){SetWidth("BannerLayer",WinW)});
onResize(resizeMargin);
onResize(function(){SetWidth("FooterLayer",WinW);SetTop("FooterLayer",WinH-30);});
onResize(resizeSeparator);
EnableDrag(document.getElementById("separatorLayer"),marginMove,marginMove);
if (UseShortcuts!=null)
 { var td = document.getElementById("oosyntax");
   var widget ='<input type="checkbox" id="OOcheckbox" '+ (UseShortcuts?'checked':'') + ' onclick="OOcheckboxChange(this);"> ' + AbbrevLabel;
   td.innerHTML = widget;
   td.title =AbbrevHint;
   td.alt =AbbrevHint;


 }
doc = sortObject(doc);
ShowFunctions();
Show(doc["YAPI"]?"YAPI":"Module","");


window.onresize = windowResized;
-->
</script>

</BODY>


</HEAD>

